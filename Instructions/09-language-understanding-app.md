---
lab:
  title: Language Understanding 앱 만들기(사용되지 않음)
  module: Module 5 - Creating Language Understanding Solutions
---

# 이제 Azure에서: Language Understanding 앱 만들기

Language Understanding 서비스에서는 언어 모델을 캡슐화하는 앱을 정의할 수 있습니다. 애플리케이션은 이 모델을 통해 사용자의 자연어 입력을 해석하고, 사용자의 *의도*(사용자가 달성하려는 목표)를 예측하고, 해당 의도를 적용해야 하는 *엔터티*를 식별할 수 있습니다.

예를 들어 시계 애플리케이션용 Language Understanding 앱은 다음과 같은 입력을 처리할 수 있습니다.

*What is the time in London?*

이러한 입력 유형의 예가 발화(사용자가 말하거나 입력하는 내용)입니다. 이 발화에서 원하는 의도는 특정 위치(엔터티), 즉 여기서는 런던의 시간을 확인하는 것입니다.  

> **참고**: Language Understanding 앱은 사용자 의도를 예측하여 해당 의도가 적용되는 엔터티를 식별하는 작업을 수행합니다. 하지만 의도를 충족하는 데 필요한 작업을 실제로 수행하지는 <u>않습니다</u>. 예를 들어 시계 애플리케이션은 언어 앱을 사용해 사용자가 런던의 시간을 확인하려 한다는 것을 파악할 수는 있습니다. 그러나 이처럼 의도가 파악되고 나면 클라이언트 애플리케이션 자체가 논리를 구현해 정확한 시간을 확인하여 사용자에게 표시해야 합니다.

## 이 과정용 리포지토리 복제

이 랩에서 작업을 수행 중인 환경에 **AI-102-AIEngineer** 코드 리포지토리를 아직 복제하지 않았다면 다음 단계에 따라 리포지토리를 지금 복제합니다. 리포지토리를 복제한 경우에는 Visual Studio Code에서 복제한 폴더를 엽니다.

1. Visual Studio Code를 시작합니다.
2. 팔레트를 열고(Shift+Ctrl+P) **Git: Clone** 명령을 실행하여 `https://github.com/MicrosoftLearning/AI-102-AIEngineer` 리포지토리를 로컬 폴더(아무 폴더나 관계없음)에 복제합니다.
3. 리포지토리가 복제되면 Visual Studio Code에서 폴더를 엽니다.
4. 리포지토리의 C# 코드 프로젝트를 지원하는 추가 파일이 설치되는 동안 기다립니다.

    > **참고**: 빌드 및 디버그에 필요한 자산을 추가하라는 메시지가 표시되면 **나중에**를 선택합니다.

## Language Understanding 리소스 만들기

Language Understanding 서비스를 사용하려면 다음과 같은 두 가지 종류의 리소스가 필요합니다.

- *작성* 리소스: Language Understanding 앱을 정의하고 학습시킨 후 테스트하는 데 사용됩니다. Azure 구독에서 **Language Understanding - Authoring** 리소스여야 합니다.
- *예측* 리소스: Language Understanding 앱을 게시하고 이 앱을 사용하는 클라이언트 애플리케이션을 요청을 처리하는 데 사용됩니다. Azure 구독에서 **Language Understanding** 또는 **Cognitive Services** 리소스여야 합니다.

     > **중요**: 작성 리소스는 유럽, 오스트레일리아, 미국의 세 *지역* 중 하나에서 생성되어야 합니다. 유럽 또는 오스트레일리아 작성 리소스에서 만드는 Language Understanding 앱은 각각 유럽 또는 오스트레일리아의 예측 리소스에만 배포할 수 있습니다. 미국 작성 리소스에서 만드는 모델은 유럽 및 오스트레일리아를 제외한 모든 Azure 위치의 예측 리소스에 배포할 수 있습니다. 작성 위치와 예측 위치 일치에 대한 자세한 내용은 [작성 및 게시 지역 설명서](https://docs.microsoft.com/azure/cognitive-services/luis/luis-reference-regions)를 참조하세요.

Language Understanding 작성 리소스와 예측 리소스가 아직 없으면 다음 작업을 수행합니다.

1. `https://portal.azure.com`의 Azure Portal을 열고 Azure 구독과 연관된 Microsoft 계정을 사용하여 로그인합니다.
2. **&#65291;리소스 만들기** 단추를 선택하고 *language understanding*을 검색한 후에 다음 설정을 사용하여 **Language Understanding** 리소스를 만듭니다.

    *Language Understanding(Azure Cognitive Services)* 이 <u>아닌</u> **Language Understanding**

    - **생성 옵션**: 둘 다
    - **구독**: ‘Azure 구독’
    - **리소스 그룹**: 리소스 그룹 선택 또는 만들기(제한된 구독을 사용 중이라면 새 리소스 그룹을 만들 권한이 없을 수도 있으므로 제공된 리소스 그룹 사용)
    - **이름**: *고유 이름 입력*
    - **작성 위치**: *기본 위치 선택*
    - **가격 책정 계층 작성**: F0
    - **예측 위치**: 작성 위치와 같은 위치
    - **예측 가격 책정 계층**: F0
3. 리소스를 만들 때까지 기다렸다가 두 개의 Language Understanding 리소스가 프로비저닝되었는지 확인합니다. 하나는 작성용이고 다른 하나는 예측용입니다. 이 항목을 생성된 리소스 그룹으로 이동하여 두 항목을 모두 볼 수 있습니다. **리소스로 이동**을 선택하면 *작성* 리소스가 열립니다.

## Language Understanding 앱 만들기

이제 작성 리소스를 만들었으므로 해당 리소스를 사용하여 Language Understanding 앱을 만들 수 있습니다.

1. 새 브라우저 탭에서 Language Understanding 포털 `https://www.luis.ai`를 엽니다.
2. Azure 구독과 연결된 Microsoft 계정으로 로그인합니다. Language Understanding 포털에 처음 로그인하는 경우 계정 세부 정보에 액세스할 수 있는 일부 권한을 앱에 부여해야 할 수 있습니다. 그런 후에 Azure 구독 및 방금 만든 작성 리소스를 선택하여 *시작* 단계를 완료합니다.

    > **참고**: 계정이 각기 다른 디렉터리의 여러 구독과 연결되어 있으면 Language Understanding 리소스를 프로비전한 구독이 포함되어 있는 디렉터리로 전환해야 할 수 있습니다.

3. **대화 앱** 페이지에서 구독 및 Language Understanding 작성 리소스가 선택되어 있는지 확인합니다. 그런 후에 다음 설정을 사용하여 대화용 새 앱을 만듭니다.
    - **이름**: Clock
    - **Culture**: 영어(*이 옵션을 사용할 수 없으면 공백으로 둠*)
    - **설명**: 자연어 시계
    - **예측 리소스**: *Language Understanding 예측 리소스*

    **Clock** 앱이 자동으로 열리지 않으면 앱을 엽니다.
    
    효과적인 Language Understanding 앱을 만들기 위한 팁이 포함된 패널이 표시되면 닫습니다.

## 의도 만들기

새 앱에서는 먼저 몇 가지 의도를 정의합니다.

1. **의도** 페이지에서 **65291; 만들기**를 클릭하여 새 의도 **GetTime**을 만듭니다.
2. **GetTime** 의도에서 예제 사용자 입력으로 다음 발화를 추가합니다.

    *what is the time?*

    *what time is it?*

3. 이러한 발화를 추가한 후 **의도** 페이지로 돌아와서 다음 발화가 포함된 새 의도 **GetDay**를 더 추가합니다.

    *what is the day today?*

    *what day is it?*

4. 이러한 발화를 추가한 후 **의도** 페이지로 돌아와서 다음 발화가 포함된 새 의도 **GetDate**를 더 추가합니다.

    *what is the date today?*

    *what date is it?*

5. 이러한 발화를 추가한 후 **의도** 페이지로 돌아와서 **None** 의도를 선택합니다. 이 의도는 언어 모델에서 정의한 어떤 의도에도 매핑되지 않는 입력용 대체 의도로 제공됩니다.
6. **None** 의도에 다음 발화를 추가합니다.

    *hello*

    *goodbye*

## 앱 학습 및 테스트

이제 몇 가지 의도를 추가했으므로 앱을 학습시켜 사용자 입력에서 정확하게 예측을 할 수 있는지 확인해 보겠습니다.

1. 포털 오른쪽 위에서 **학습**을 선택하여 앱 학습을 진행합니다.
2. 앱 학습이 완료되면 **테스트를** 선택하여 테스트 패널을 표시한 후에 다음 테스트 발화를 입력합니다.

    *what's the time now?*

    반환되는 결과를 검토하여 예측한 의도(**GetTime**이어야 함), 그리고 모델이 예측한 의도를 대상으로 계산한 가능성을 나타내는 신뢰도 점수가 포함되어 있음을 확인합니다.

3. 다음 테스트 발화를 사용해 봅니다.

    *tell me the time*

    이번에도 예측한 의도 및 신뢰도 점수를 검토합니다.

4. 다음 테스트 발화를 사용해 봅니다.

    *what's today?*

    이 경우 모델은 **GetDay** 의도를 예측해야 합니다.

5. 마지막으로 다음 테스트 발화를 사용해 봅니다.

    *hi*

    이번에는 **None** 의도가 반환되어야 합니다.

6. 테스트 패널을 닫습니다.

## 엔터티 추가

지금까지 의도에 매핑되는 간단한 발화 몇 가지를 정의했습니다. 대다수 실제 애플리케이션에는 더 복잡한 발화가 포함됩니다. 이러한 발화에서 구체적인 데이터 엔터티를 추출하여 의도 예측을 위한 추가 컨텍스트를 수집해야 합니다.

### *기계 학습된* 엔터티 추가

가장 흔히 사용되는 엔터티 유형은 *기계 학습된* 엔터티입니다. 앱은 이 엔터티에서 예제를 기준으로 엔터티 값을 식별합니다.

1. **엔터티** 페이지에서 **&#65291; 만들기**를 클릭하여 새 엔터티를 만듭니다.
2. **엔터티 만들기** 대화 상자에서 **기계 학습된** 엔터티인 **Location**을 만듭니다.
3. **Location** 엔터티가 작성되면 **의도** 페이지로 돌아와서 **GetTime** 의도를 선택합니다.
4. 다음과 같은 새 예제 발화를 입력합니다.

    *what time is it in London?*

5. 이 발화를 추가한 후 단어 ***london***을 선택합니다. 그러면 표시되는 드롭다운 목록에서 **Location**을 선택하여 "london"이 위치의 예임을 지정합니다.
6. 다른 예제 발화를 추가합니다.

    *what is the current time in New York?*

7. 이 발화를 추가한 후 단어 ***new york***을 선택하여 **Location** 엔터티에 매핑합니다.

### *list* 엔터티 추가

엔터티의 유효한 값을 특정 단어 및 동의어 목록으로 제한할 수 있는 경우도 있습니다. 이렇게 하면 앱이 발화의 엔터티 인스턴스를 쉽게 식별할 수 있습니다.

1. **엔터티** 페이지에서 **&#65291; 만들기**를 클릭하여 새 엔터티를 만듭니다.
2. **엔터티 만들기** 대화 상자에서 **List** 엔터티인 **Weekday**를 만듭니다.
3. 다음의 **정규화된 값** 및 **동의어**를 추가합니다.

    | 정규화된 값 | 동의어|
    |-------------------|---------|
    | sunday | sun |
    | monday | mon |
    | tuesday | tue |
    | wednesday | wed |
    | thursday | thu |
    | friday | fri |
    | saturday | sat |

3. **Weekday** 엔터티가 작성되면 **의도** 페이지로 돌아와서 **GetDate** 의도를 선택합니다.
4. 다음과 같은 새 예제 발화를 입력합니다.

    *what date was it on Saturday?*

5. 이 발화를 추가한 후 **saturday**가 **Weekday** 엔터티에 자동으로 매핑되었는지 확인합니다. saturday가 자동 매핑되지 않았으면 단어 ***saturday***를 선택합니다. 그러면 표시되는 드롭다운 목록에서 **Weekday**를 선택합니다.
6. 다른 예제 발화를 추가합니다.

    *what date will it be on Friday?*

7. 이 발화를 추가한 후 **friday**가 **Weekday** 엔터티에 매핑되는지 확인합니다.

### *Regex* 엔터티 추가

일련 번호, 양식 코드, 날짜 등 특정 형식으로 된 엔터티도 있습니다. 이 경우 앱이 일치하는 엔터티 값을 식별할 수 있도록 필요한 형식을 설명하는 정규식(*regex*)을 정의할 수 있습니다.

1. **엔터티** 페이지에서 **&#65291; 만들기**를 클릭하여 새 엔터티를 만듭니다.
2. **엔터티 만들기** 대화 상자에서 다음 정규식을 사용하여 **Regex** 엔터티인 **Date**를 만듭니다.

    ```
    [0-9]{2}/[0-9]{2}/[0-9]{4}
    ```

    > **참고**: 이 엔터티는 *01/11/2020*과 같은 숫자 2개+"/"+숫자 2개+"/"+숫자 4개 형식을 확인하는 간단한 정규식입니다. 그러므로 *56/00/9999* 등의 잘못된 날짜도 허용됩니다. 하지만 정규식 엔터티는 날짜 값의 유효성을 검사하는 것이 아니라 날짜로 *의도*하여 입력한 데이터 항목을 식별하는 데 사용된다는 점을 기억해야 합니다.

3. **Date** 엔터티가 작성되면 **의도** 페이지로 돌아와서 **GetDay** 의도를 선택합니다.
4. 다음과 같은 새 예제 발화를 입력합니다.

    *what day was 01/01/1901?*

5. 이 발화를 추가한 후 **01/01/1901**이 **Date** 엔터티에 자동으로 매핑되었는지 확인합니다. 이 날짜가 자동 매핑되지 않았으면 ***01/01/1901***을 선택합니다. 그러면 표시되는 드롭다운 목록에서 **Date**를 선택합니다.
6. 다른 예제 발화를 추가합니다.

    *what day will it be on 12/12/2099?*

7. 이 발화를 추가한 후 **12/12/2099**가 **Date** 엔터티에 매핑되는지 확인합니다.

### 앱 다시 학습시키기

이제 언어 모델을 수정했으므로 앱을 다시 학습시켜 테스트를 다시 진행해야 합니다.

1. 포털 오른쪽 위에서 **학습**을 선택하여 앱을 다시 학습시킵니다.
2. 앱 학습이 완료되면 **테스트를** 선택하여 테스트 패널을 표시한 후에 다음 테스트 발화를 입력합니다.

    *what's the time in Edinburgh?*

3. 반환되는 결과를 검토합니다. 앱이 **GetTime** 의도를 예측해야 합니다. 그런 다음 **검사**를 선택하고 추가 검사 패널이 표시되면 **ML 엔터티** 섹션을 살펴봅니다. 모델이 "edinburgh"가 **Location** 엔터티 인스턴스임을 예측해야 합니다.
4. 다음 발화를 테스트해 봅니다.

    *what date is it on Friday?*

    *what's the date on Thu?*

    *what was the day on 01/01/2020?*

5. 테스트를 완료한 후 검사 패널을 닫되 테스트 패널은 열어 둡니다.

## 일괄 처리 테스트 수행

테스트 창을 사용해 개별 발화를 대화형으로 테스트할 수 있습니다. 그러나 더욱 복잡한 언어 모델의 경우에는 대개 *일괄 처리 테스트*를 수행하는 것이 더 효율적입니다.

1. Visual Studio Code에서 **09-luis-app** 폴더의 **batch-test.json** 파일을 엽니다. 이 파일은 앞에서 만든 시계 언어 모델용 테스트 사례 여러 개가 포함된 JSON 문서로 구성되어 있습니다.
2. Language Understanding 포털의 테스트 패널에서 **일괄 처리 테스트 패널**을 선택합니다. 그런 다음 **65291; 가져오기**를 선택하고 **batch-test.json** 파일을 가져와 이름 **clock-test**를 할당합니다.
3. 일괄 처리 테스트 패널에서 **clock-test** 테스트를 실행합니다.
4. 테스트가 완료되면 **결과 보기**를 선택합니다.
5. 결과 페이지에서 예측 결과가 표시된 오차 행렬을 확인합니다. 이 행렬에는 오른쪽 목록에서 선택한 의도나 엔터티에 대한 진양성, 가양성, 참 부정 및 거짓 부정이 표시됩니다.

    ![Language Understanding 일괄 처리 테스트 결과에 해당하는 오차 행렬](./images/luis-confusion-matrix.jpg)

    > **참고**: 각 발화는 각 의도에 대해 양수 또는 음수로 점수가 매겨집니다. 예를 들어 “몇 시입니까?”  *GetTime* 의도에 대해 **양수**로, *GetDate* 의도에 대해 **음수**로 채점되어야 합니다. 오차 행렬의 점수에는 정확하게 예측된 발화(참)와 잘못 예측된 발화(거짓)가 선택한 의도의 긍정 및 부정으로 표시됩니다.   

6. **GetDate** 의도를 선택하고 오차 행렬의 아무 점수나 선택하여 발화 및 예측의 신뢰도 점수를 포함한 예측 세부 정보를 확인합니다. 그런 다음 **GetDay**, **GetTime**, **None** 의도를 선택하고 각각의 예측 결과를 확인합니다. 앱이 의도를 정확하게 예측할 수 있어야 합니다.

    > **참고**: 사용자 인터페이스에서 이전에 선택한 점수가 지워지지 않을 수도 있습니다.

7. **Location** 엔터티를 선택하고 오차 행렬에서 예측 결과를 확인합니다. 특히 거짓 부정 예측을 자세히 살펴봅니다. 거짓 부정이란 앱이 발화에서 지정된 위치를 예측하지 못한 경우입니다. 즉, 의도에 샘플 발화를 더 추가하고 모델을 다시 학습시켜야 할 수 있습니다.
8. 일괄 처리 테스트 패널을 닫습니다.

## 앱 게시

실제 프로젝트에서는 만족할 만한 예측 성능이 제공될 때까지 의도와 엔터티를 여러 번 미세 조정하고 모델을 다시 학습시켜 테스트를 다시 진행합니다. 그런 후에 클라이언트 애플리케이션이 사용하도록 앱을 게시합니다.

1. Language Understanding 포털의 오른쪽 위에서 **게시**를 선택합니다.
2. **프로덕션 슬롯**을 선택하고 앱을 게시합니다.
3. 게시가 완료되면 Language Understanding 포털 위쪽에서 **관리**를 선택합니다.
4. **설정** 페이지에서 **앱 ID**를 확인합니다. 클라이언트 애플리케이션이 앱을 사용하려면 이 ID가 필요합니다.
5. **Azure 리소스** 페이지에서 예측 리소스의 **기본 키**, **보조 키** 및 **엔드포인트 URL**을 확인합니다. 이러한 정보가 있어야 앱을 사용할 수 있습니다. 클라이언트 애플리케이션이 예측 리소스에 연결하여 인증을 하려면 엔드포인트와 키 중 하나가 필요합니다.
6. Visual Studio Code의**09-luis-app**폴더에서 **GetIntent.cmd** 배치 파일을 선택하여 이 파일에 포함된 코드를 확인합니다. 이 명령줄 스크립트는 cURL을 사용하여 지정된 애플리케이션 및 예측 엔드포인트용으로 Language Understanding REST API를 호출합니다.
7. 스크립트의 자리 표시자 값을 Language Understanding 앱의 **앱 ID**, **엔드포인트 URL** 및 **기본 키** 또는 **보조 키** 중 하나로 바꾸고 업데이트한 파일을 저장합니다.
8. **09-luis-app** 폴더를 마우스 오른쪽 단추로 클릭하고 통합 터미널을 엽니다. 그런 후에 다음 명령을 입력합니다(따옴표도 포함해야 함).

    ```
    GetIntent "What's the time?"
    ```

9. 앱이 반환하는 JSON 응답을 검토합니다. 입력한 명령에 대해 예측된 점수가 가장 높은 의도(**GetTime**이어야 함)가 표시됩니다.
10. 다음 명령을 시도합니다.

    ```
    GetIntent "What's today's date?"
    ```

11. 응답에서 **GetDate** 의도가 예측되었는지를 확인합니다.
12. 다음 명령을 시도합니다.

    ```
    GetIntent "What time is it in Sydney?"
    ```

13. 응답에 **Location** 엔터티가 포함되어 있는지 확인합니다.

14. 다음 명령을 실행하여 응답을 살펴봅니다.

    ```
    GetIntent "What time is it in Glasgow?"
    ```

    ```
    GetIntent "What's the time in Nairobi?"
    ```

    ```
    GetIntent "What's the UK time?"
    ```
15. 몇 가지 변형 명령을 더 실행해 봅니다. **GetTime** 의도는 올바르게 예측하지만 **Location** 엔터티는 검색하지 못하는 응답을 몇 개 생성해야 합니다.

    터미널은 나중에 다시 사용할 것이므로 열어 둡니다.

## *활성 학습* 적용

엔드포인트에 제출된 발화 기록을 토대로 Language Understanding 앱을 개선할 수 있습니다. 이러한 개선 방식이 *활성 학습*입니다.

이전 절차에서는 cURL을 사용하여 앱 엔드포인트에 요청을 제출했습니다. 이러한 요청에는 쿼리 로깅 옵션이 포함되어 있었습니다. 따라서 앱이 활성 학습에 사용할 쿼리를 추적할 수 있습니다.

1. Language Understanding 포털에서 **빌드**를 선택하고 **엔드포인트 발화 검토** 페이지를 확인합니다. 이 페이지에는 서비스가 검토 대상으로 플래그를 지정한 로깅된 발화가 나열됩니다.
2. 의도와 새 위치 엔터티(원래 학습 발화에는 포함되지 않았던 엔터티)가 정확하게 예측된 발화의 경우 **&#10003;** 을 선택하여 엔터티를 확인한 다음 **&#10514;** 아이콘을 사용하여 해당 발화를 학습 예제로 의도에 추가합니다.
3. **GetTime** 의도는 정확하게 식별되었지만 **Location** 엔터티는 식별되지 <u>않은</u> 발화 예제를 찾은 다음 위치 이름을 선택하여 **location** 엔터티에 매핑합니다. 그런 후에 **&#10514;** 아이콘을 사용하여 해당 발화를 학습 예제로 의도에 추가합니다.
4. **의도** 페이지로 이동하여 **GetTime** 의도를 열고 제안 발화가 추가되었음을 확인합니다.
5. Language Understanding 포털 위쪽에서 **학습**을 선택하여 앱을 다시 학습시킵니다.
6. Language Understanding 포털 오른쪽 위에서 **게시**를 선택하여 **프로덕션 슬롯**에 앱을 다시 게시합니다.
7. **09-luis-app** 폴더의 터미널로 돌아와서 **GetIntent** 명령을 사용해 활성 학습 중에 추가 및 수정한 발화를 제출합니다.
8. 이제 결과에 **Location** 엔터티가 포함되어 있음을 확인합니다. 그런 다음 동일 구문을 사용하되 다른 위치(예: *Berlin*)를 지정하는 다른 발화를 실행해 봅니다.

## 앱 내보내기

Language Understanding 포털을 사용하면 언어 앱을 개발하고 테스트할 수 있습니다. 그러나 DevOps용 소프트웨어 개발 프로세스에서는 CI/CD(연속 통합/지속적인 업데이트) 파이프라인에 포함할 수 있는 앱의 원본 제어 정의를 유지 관리해야 합니다. 코드 스크립트에서 REST API 또는 Language Understanding SDK를 사용하여 앱을 만들고 학습시킬 수도 있습니다. 하지만 포털을 사용하여 앱을 만든 후에 다른 Language Understanding 인스턴스에서 가져와 다시 학습시킬 수 있는 *.lu* 파일로 내보내는 방식이 더 간편합니다. 이 방식을 사용하면 생산성이 우수한 포털을 활용하는 동시에 앱의 이동성과 재현 가능성도 유지할 수 있습니다.

1. Language Understanding 포털에서 **관리**를 선택합니다.
2. **버전** 페이지에서 앱의 현재 버전을 선택합니다(버전은 하나뿐임).
3. **내보내기** 드롭다운 목록에서 **LU로 내보내기**를 선택합니다. 그런 다음 브라우저에서 메시지가 표시되면 **09-luis-app** 폴더에 파일을 저장합니다.
4. Visual Studio Code에서 방금 내보낸 후 다운로드한 **.lu** 파일을 엽니다(Marketplace에서 해당 파일을 읽을 수 있는 확장을 검색하라는 메시지가 표시되면 해당 메시지를 해제하면 됨). LU는 사람이 읽을 수 있는 형식이므로 팀 개발 환경에서 Language Understanding 앱의 정의를 효율적으로 문서화할 수 있습니다.

## 추가 정보

**Language Understanding** 서비스를 사용하는 방법에 대한 자세한 내용은 [Language Understanding 설명서](https://docs.microsoft.com/azure/cognitive-services/luis/)를 참조하세요.
